# Часть 4: Начинаем работать с C

Знание ассемблера важно, но многие программы разумней писать на C. В этой части
мы напишем простую программу на C, скомпилируем её, исследуем получившийся
объектный файл, правильно скомпонуем и запустим. После этого ещё немного изучим
gdb.

Вот наша простая программа:

`loopc.c`

```c
#include <stdint.h>

static const uint32_t loop_start = 0x12345678;
static const uint32_t loop_increment = 3;
static uint32_t loop_value_1 = loop_start;
static uint32_t loop_value_2;

void reset_exception_handler(void)
{
    for (;;)
    {
        loop_value_2 = loop_value_1 + loop_increment;
        loop_value_1 = loop_value_2;
    }
}
```

В этой программе имеются следующие элементы:

1. Глобальные константы.
2. Инициализированная глобальная переменная.
3. Неинициализированная глобальная переменная.
4. Ну и, конечно, код.

Скомпилируем эту программу:

```
arm-none-eabi-gcc -mcpu=cortex-m3 -g -O0 -c -o loopc.o loopc.c
```

Параметр `-mcpu=cortex-m3` указывает компилятору, что мы хотим сгенерировать код
для ARM Cortex M3.

Параметр `-g` указвыает компилятору, что мы хотим добавить в объектный файл
отладочную информацию. Она пригодится поздней, когда мы будем запускать
программу под отладкой.

Параметр `-O0` указывает компилятору, что мы не хотим оптимизировать код. Для
реальных программ стоит указывать параметр `-Os`, `-O2` или `-O3`, в зависимости
от того, хотите ли вы оптимизировать выходной код по размеру или скорости. Но
для нашего случая оптимизация совсем ни к чему и только помешает.

Параметр `-c` указывает компилятору, что мы хотим только скомпилировать файл.
Без него компилятор вызовет линкер, это нам не нужно.

После компиляции исследуем получившийся объектный файл:

```
arm-none-eabi-objdump -D loopc.o

loopc.o:     file format elf32-littlearm


Disassembly of section .text:

00000000 <reset_exception_handler>:
   0:	b480      	push	{r7}
   2:	af00      	add	r7, sp, #0
   4:	4b05      	ldr	r3, [pc, #20]	@ (1c <reset_exception_handler+0x1c>)
   6:	681b      	ldr	r3, [r3, #0]
   8:	2203      	movs	r2, #3
   a:	4413      	add	r3, r2
   c:	4a04      	ldr	r2, [pc, #16]	@ (20 <reset_exception_handler+0x20>)
   e:	6013      	str	r3, [r2, #0]
  10:	4b03      	ldr	r3, [pc, #12]	@ (20 <reset_exception_handler+0x20>)
  12:	681b      	ldr	r3, [r3, #0]
  14:	4a01      	ldr	r2, [pc, #4]	@ (1c <reset_exception_handler+0x1c>)
  16:	6013      	str	r3, [r2, #0]
  18:	e7f4      	b.n	4 <reset_exception_handler+0x4>
  1a:	bf00      	nop
	...

Disassembly of section .data:

00000000 <loop_value_1>:
   0:	12345678 	eorsne	r5, r4, #120, 12	@ 0x7800000

Disassembly of section .bss:

00000000 <loop_value_2>:
   0:	00000000 	andeq	r0, r0, r0

Disassembly of section .rodata:

00000000 <loop_start>:
   0:	12345678 	eorsne	r5, r4, #120, 12	@ 0x7800000

00000004 <loop_increment>:
   4:	00000003 	andeq	r0, r0, r3

...
```

Нас интересуют первые четыре секции: `.text`, `.data`, `.bss` и `.rodata`.
Остальные секции содержат отладочную и прочую служебную инфомацию и в конечный
файл не попадут.

Как видно, секция `.text` содержит машинный код нашей функции. Компилятор без
оптимизации компилирует весьма многословный код и разбираться в нём мы не будем,
хотя в целом там нет ничего сложного.

Секция `.data` содержит инициализированные глобальные переменные. В нашем случае
это переменная loop_value_1.

Секция `.bss` содержит неинициализированные глобальные переменные. В нашем
случае это переменная loop_value_2.

Секция `.rodata` содержит константы. В нашем случае это константы loop_start и
loop_increment.

Теперь давайте подумаем, как эти секции должны располагаться в памяти. Секция
`.text` по смыслу полностью аналогична секции `code` из второй части. Её мы
просто запишем на флеш-память после таблицы векторов. Секция `.rodata` по сути
ничем не отличается, её тоже запишем на флеш-память. Секция `.bss` содержит
переменные. Для работы с переменными нужно использовать SRAM, поэтому секция
`.bss` будет расположена именно там. Инициализировать её не надо, поэтому
никаких дополнительных действий не потребуется.

А вот с секцией `.data` всё совсем непросто. С одной стороны эта секция содержит
переменные, поэтому её нужно расположить в SRAM. Но с другой стороны эти
переменные при старте программы должны быть инициализированы определёнными
значениями. Но когда наша программа запускается, содержимое SRAM не определено,
а эти начальные значения можно сохранить только во флеш-памяти.

Решение тут такое:

1. Секцию `.data` нужно разместить во флеш-памяти, чтобы там хранились
   инициализированные значения.
2. Также секцию `.data` нужно разместить в SRAM и все адреса в коде должны
   указывать именно в SRAM.
3. Необходимо в самом начале работы программы, ещё перед вызовом нашей функции
   `reset_exception_handler` скопировать секцию `.data` из флеш-памяти в SRAM.

Для этого мы напишем код на языке ассемблера, который будет вызван в самом
начале, скопирует секцию `.data` и передаст управление нашей функции на C.

Вот наш линкер скрипт:

`loopc.ld`:

```
MEMORY
{
    Flash : ORIGIN = 0x08000000, LENGTH = 64K
    SRAM : ORIGIN = 0x20000000, LENGTH = 20K
}

SECTIONS {
    .isr_vector :
    {
        LONG(0x20000000 + 20K);
        LONG(_startup | 1);
        . = 0x130;
    } > Flash

    .text :
    {
        . = ALIGN(4);
        *(.text)
        . = ALIGN(4);
    } > Flash

    .rodata :
    {
        . = ALIGN(4);
        *(.rodata)
        . = ALIGN(4);
    } > Flash

    .bss : {
        . = ALIGN(4);
        *(.bss)
        . = ALIGN(4);
    } > SRAM

    .data : {
        . = ALIGN(4);
        _flash_data_start = LOADADDR(.data);
        _sram_data_start = .;
        *(.data)
        _sram_data_end = .;
        . = ALIGN(4);
    } > SRAM AT> Flash
}
```

Он уже гораздо сложней предыдущих. Во-первых в нём появился раздел `MEMORY`, в
котором описываются регионы памяти. Без них нам не расположить `.data` в двух
местах. Во-вторых мы добавили множество выходных секций с именами, идентичными
входным. В-третьих мы добавили инструкции `. = ALIGN(4);`, которые выравнивают
начало и конец каждой выходной секции по границе, кратной четырём байтам. И
в-чётвёртых у нас появилась довольно сложная секция `.data`. Давайте разберём её
по строчкам.

Начнём с последней строчки: `> SRAM AT> Flash`. Эта строчка означает, что секция
располагается в регионе `SRAM`, но загружается в регион `Flash`. Что значит
"располагается в регионе `SRAM`"? Это означает, что все указатели, которые
ссылаются на эту секцию, после компоновки будут указывать в `SRAM`. Иными
словами, когда наша программа будет менять значения переменной `loop_value_1`,
она будет это делать в SRAM, а не пытаться менять значения во флеш-памяти. А что
значит "загружается в регион `Flash`"? Это означает, что в выходном файле
значения, которыми должны инициализироваться переменные, будут записаны во
флеш-память.

На выравниваниях не будем останавливаться, тут ничего сложного. Посмотрим на
строчку `_flash_data_start = LOADADDR(.data)`. Эта строчка объявляет символ
`_flash_data_start` и присваивает ему адрес начала секции `.data` во
флеш-памяти. Далее идёт строчка `_sram_data_start = .`. Она объявляет символ
`_sram_data_start` и присваивает ему адрес начала секции `.data` в SRAM. Потом
идёт `*(.data)`, с этим синтаксисом мы уже знакомы, все секции с именем `.data`
из всех входных файлов (в нашем случае это только `loopc.o`) будут скопированы в
выходную секцию `.data`. И наконец идёт строчка `_sram_data_end = .`. Она
объявляет символ `_sram_data_end` и присваивает ему адрес конца секции `.data` в
SRAM.

В дальнейшем мы сможем использовать значения символов `_flash_data_start`,
`_sram_data_start` и `_sram_data_end` в коде, который будет копировать начальные
значения для переменных из секции `.data` из флеш-памяти в SRAM.

Важно понимать, что все эти символы вычисляются линкером во время компоновки
конечного файла и в нём будут присутствовать в виде готовых констант. Как,
наверное, уже видно, линкер уже выполняет весьма нетривиальную роль. И если в
прошлых программах при большом желании без него можно было бы и обойтись, собрав
конечный файл по кусочкам, то в этой программе без линкера никуда.

Внимательный читатель мог заметить, что мы по адресу `0x08000004` записываем
значение символа `_startup`, а не `reset_exception_handler`. Именно этот код,
который мы сейчас напишем, и будет инициализировать переменные из секции
`.data`, а потом уже перейдёт к `reset_exception_handler`. Стоит отметить, что
использование переменных с подчёркиванием в коде на C не рекомендуется, все
переменные такого рода считаются зарезервированными для деталей реализации.
Именно поэтому мы и объявляем такие символы, в коде на C они не должны
появиться. Если бы мы использовали имя `startup` или `flash_data_start`, то в
коде на C ничего бы не мешало объявить функцию с таким же именем, и получилась
бы неприятная коллизия. Конечно в нашем простом случае это не случится, но в
общем случае стоит иметь это в виду. Наш линкер и наш будущий код инициализации
секции `.data` как раз относятся к таким деталям реализации.

Итак пора написать код `_startup`. Мы это сделаем на языке ассемблера, чтобы к
моменту запуска кода на C всё уже было инициализировано и готово к
использованию.

`startup.s`:

```
.cpu cortex-m3
.syntax unified
.thumb

.global _startup

.text

_startup:
ldr r0, =_flash_data_start
ldr r1, =_sram_data_start
ldr r2, =_sram_data_end

copy_loop:
cmp r1, r2
bge end_copy
ldr r3, [r0], #4
str r3, [r1], #4
b copy_loop

end_copy:
b reset_exception_handler
```

Псевдокод, соответствующий этому коду, выглядит так:

```
_startup:
r0 := _flash_data_start
r1 := _sram_data_start
r2 := _sram_data_end

copy_loop:
if r1 >= r2 then goto end_copy
r3 := [r0]
r0 := r0 + 4
[r1] := r3
r1 := r1 + 4
goto copy_loop

end_copy:
goto reset_exception_handler
```

Работа по программированию на этом закончена. `Makefile` приводить не будем, там
всё тривиально. Соберём программу и приступим к следующей задач: запустить эту
программу под отладкой. На этот раз вместо st-flash будем использовать gdb, он
тоже умеет прошивать микропроцессор, да ещё и используя `.elf` файл, ему даже
`.bin`-файл не нужен.

Как и в прошлый раз, запустим в одной вкладке терминала `st-util`, а в другой
`arm-none-eabi-gdb`. Подключимся командой `target remote 127.0.0.1:4242`.

Теперь загрузим программу:

```
(gdb) file loopc.elf
A program is being debugged already.
Are you sure you want to change the file? (y or n) y
Reading symbols from loopc.elf...
(gdb) load
Loading section .isr_vector, size 0x130 lma 0x8000000
Loading section .text, size 0x48 lma 0x8000130
Loading section .rodata, size 0x8 lma 0x8000178
Loading section .data, size 0x4 lma 0x8000180
Start address 0x08000130, load size 388
Transfer rate: 1 KB/sec, 97 bytes/write.
```

Видно, что gdb сумел прочитать наш ELF-файл, распознать в нём все секции,
которые нужно загрузить и загрузил их по необходимым смещениям.

У gdb есть очень полезная команда `display`. Мы ей указываем формат выражение,
аналогично команде `print`, а она распечатывает это выражение при каждом шаге
программы. Воспользуемся этой командой для того, чтобы дизассемблировать
выполняющийся код:

```
(gdb) display/6i $pc - 2
1: x/6i $pc - 2
   0x800012e:	movs	r0, r0
=> 0x8000130:	ldr	r0, [pc, #20]	@ (0x8000148)
   0x8000132:	ldr	r1, [pc, #24]	@ (0x800014c)
   0x8000134:	ldr	r2, [pc, #24]	@ (0x8000150)
   0x8000136:	cmp	r1, r2
   0x8000138:	bge.n	0x8000144
```

Можно распознать в этом коде содержимое файла startup.s. Сделаем шаг:

```
(gdb) stepi
0x08000132 in ?? ()
1: x/6i $pc - 2
   0x8000130:	ldr	r0, [pc, #20]	@ (0x8000148)
=> 0x8000132:	ldr	r1, [pc, #24]	@ (0x800014c)
   0x8000134:	ldr	r2, [pc, #24]	@ (0x8000150)
   0x8000136:	cmp	r1, r2
   0x8000138:	bge.n	0x8000144
   0x800013a:	ldr.w	r3, [r0], #4
```

Как и ожидалось, команда `display` распечатала обновлённый код. Теперь нажмём
`<Enter>` ничего не вводя:

```
(gdb)
0x08000134 in ?? ()
1: x/6i $pc - 2
   0x8000132:	ldr	r1, [pc, #24]	@ (0x800014c)
=> 0x8000134:	ldr	r2, [pc, #24]	@ (0x8000150)
   0x8000136:	cmp	r1, r2
   0x8000138:	bge.n	0x8000144
   0x800013a:	ldr.w	r3, [r0], #4
   0x800013e:	str.w	r3, [r1], #4
```

Это повторило предыдущую инструкцию и сделало ещё один шаг вперёд. Можно
увидеть, что после того, как startup скопирует нашу секцию `.data`, он перейдёт
на инструкцию по адресу `0x0800_0144`. Не будем шагать дальше, а поставим
отладочную точку (breakpoint, брейкпоинт) на этот адрес и запустим выполнение
программы, которая остановится там:

```
(gdb) break *0x8000144
Breakpoint 1 at 0x8000144
Note: automatically using hardware breakpoints for read-only addresses.
(gdb) continue
Continuing.

Breakpoint 1, 0x08000144 in ?? ()
1: x/6i $pc - 2
   0x8000142:	b.n	0x8000136
=> 0x8000144:	b.w	0x8000154
   0x8000148:	lsls	r0, r0, #6
   0x800014a:	lsrs	r0, r0, #32
   0x800014c:	movs	r4, r0
   0x800014e:	movs	r0, #0
```

Следующей инструкцей мы перейдём уже в скомпилированный код функции
`reset_exception_handler`. А перед этим проверим, действительно ли секция
`.data` в SRAM инициализирована. Т.к. мы загрузили ELF-файл, gdb знает про
значения всех символов и можно их использовать:

```
(gdb) print/z &_flash_data_start
$1 = 0x08000180
(gdb) print/z &_sram_data_start
$2 = 0x20000004
(gdb) print/z &_sram_data_end
$3 = 0x20000008
(gdb) x/z 0x08000180
0x8000180:	0x12345678
(gdb) x/4z 0x20000000
0x20000000 <loop_value_2>:	0xbf00bf00	0x12345678	0x443e4e0e	0x443d4d0e
```

Можно сделать вывод: что наша секция `.data` была записана во флеш-память по
адресу `0x0800_0180`, а затем скопирована в SRAM по адресу `0x2000_0004` и
занимает 4 байта. Также обратим внимание, что gdb знает про переменную
`loop_value_2` и про её адрес.

Теперь перейдём в наш код на C:

```
(gdb) stepi
reset_exception_handler () at loopc.c:9
9	{
1: x/6i $pc - 2
   0x8000152 <end_copy+14>:	movs	r0, #0
=> 0x8000154 <reset_exception_handler>:	push	{r7}
   0x8000156 <reset_exception_handler+2>:	add	r7, sp, #0
   0x8000158 <reset_exception_handler+4>:	ldr	r3, [pc, #20]	@ (0x8000170 <reset_exception_handler+28>)
   0x800015a <reset_exception_handler+6>:	ldr	r3, [r3, #0]
   0x800015c <reset_exception_handler+8>:	movs	r2, #3
```

Обратите внимание, что произошла очень важная вещь. gdb распечатал название
нашей функции `reset_exception_handler`, название файла, где эта функция
определена `loopc.c` и номер строки `9`.

Командой `list` можно распечетать окрестности выполняемого кода:

```
(gdb) list
4	static const uint32_t loop_increment = 3;
5	static uint32_t loop_value_1 = loop_start;
6	static uint32_t loop_value_2;
7
8	void reset_exception_handler(void)
9	{
10	    for (;;)
11	    {
12	        loop_value_2 = loop_value_1 + loop_increment;
13	        loop_value_1 = loop_value_2;
```

Конечно их можно и просто посмотреть в вашем редакторе, но gdb распечатает
гарантированно актуальный код (т.к. он сохранён внутри ELF-файла).

Теперь можно убрать отображение дизассемблированного кода и добавить отображение
значений переменных из кода на C:

```
(gdb) delete display 1
(gdb) display loop_value_1
2: loop_value_1 = 305419896
(gdb) display loop_value_2
3: loop_value_2 = 305419899
```

Далее будем вместо команды `stepi` (step instruction) использовать команду
`step`, которая шагает по строкам C, а не отдельным инструкциям.

```
(gdb) step
12	        loop_value_2 = loop_value_1 + loop_increment;
2: loop_value_1 = 305419899
3: loop_value_2 = 305419899
(gdb) step
13	        loop_value_1 = loop_value_2;
2: loop_value_1 = 305419899
3: loop_value_2 = 305419902
(gdb) step
12	        loop_value_2 = loop_value_1 + loop_increment;
2: loop_value_1 = 305419902
3: loop_value_2 = 305419902
```

На этом данную часть можно считать завершённой. Мы научились компилировать и,
что куда более важно, компоновать код на C, загружать его в микроконтроллер с
помощью gdb, а также отлаживать его.
